CSS选择器，结构与层叠  
===  
# CSS选择器  
要使用css对HTML页面中的元素实现一对一，一对多或者多对一的控制，这就需要用到CSS选择器。HTML页面中的元素就是通过CSS选择器进行控制的。  
## 规则结构  
每个css选择器规则都有两个基本部分：选择器(selector)和声明块(declaration block)。声明块由一个或多个声明(declaration)组成，每个
声明则是一个属性-值(property-value)。每个样式表由一系列规则组成。  
![](/image/css1.png)  
上面只是最简单情况，实际比这个复杂的多。总的来说，规则分为四大类十七种。  
## 四大类选择器  
主要是指**并联选择器，简单选择器，关系选择器，伪类。**   

1. 并联选择器是 ","分割，一种不是选择器的选择器，用于合并多个分组的结果。  
2. 简单选择器包括五种：ID选择器，标签选择器，类选择器，属性选择器，通配符选择器。   
3. 关系选择器分为四种：亲子选择器，后代选择器，相邻选择器，兄弟选择器。  
4. 伪类分为六种：动作伪类，目标伪类，语言伪类，状态伪类，结构伪类，取反伪类。  
这里对于简单的选择器，我们不再介绍，直接开始一些高级选择器。  

## 属性选择器  
CSS2.1中，属性选择器有一下四种形态  
  
|选择器|含义|示例|  
|:--:|:--:|:--:|    
|E[attr]|匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如“[cheacked]”。以下同。）|p[title] { color:#f00; }|  
|E[att=val]|匹配所有att属性等于“val”的E元素|div[class=”error”] { color:#f00; }|  
|E[att~=val]|匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素|td[class~=”name”] { color:#f00; }|  
|E[att\|=val]|匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以“val”开头的E元素，主要用于lang属性，比如“en”、“en-us”、“en-gb”等等|p[lang|=en] { color:#f00; }|   

**注：CSS 2.1 属性选择器还有一个特点就是使用多个选择器，同时满足这多个选择器：blockquote[class=quote][cite] { color:#f00; }**  
CSS3中有新增了三种属性选择器，如下：  

|选择器|含义|示例|
|:--:|:--:|:--:|  
|E[att^=”val”]|属性att的值以”val”开头的元素|div[id^="nav"] { background:#ff0; }|  
|E[att$=”val”]|属性att的值以”val”结尾的元素|div[class$=a] {color:#f00;}|  
|E[att*=”val”]|属性att的值包含”val”字符串的元素|a[title*=link] {text-decoration:underline;}|

## 关系选择器  
关系选择器是不能单独存在的，他必须在替他两类选择器组合使用，在css里，他必须加载他们中间。最初只有后代选择器(E F)，后来在CSS2.1中加入亲子
选择器(E > F)和相邻选择器(E + F)。CSS3又添加了，兄弟选择器(E ~ F)。如下：   

|选择器|含义|示例|
|:--:|:--:|:--:|   
|E F|后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔|#nav li { display:inline; }  li a { font-weight:bold; }|   
|E > F|子元素选择器，匹配所有E元素的子元素F|div > strong { color:#f00; }|  
|E + F|毗邻元素选择器，匹配所有紧随E元素之后的同级元素F|p + p { color:#f00; }|  
|E ~ F|兄弟选择器，匹配任何在E元素之后的同级F元素|p ~ ul { background:#ff0; }| 
## 伪类  
### 动作伪类  
动作伪类又分为**链接伪类**和**用户行为伪类**，其中链接伪类为`:visited`和`:link`组成，用户行为伪类为`:hover`,`:active`,`:focus`组成。
css3中又新增了如下的用户行为伪类：`:enabled`已启用的界面元素,`:disabled`已禁用的界面元素,`:checked`,`:selection`匹配突出显示的文本。  
### 目标伪类  
目标伪类`:target`伪类，指其id或者name属性与URL中的hash部分匹配上的元素。    
### 语言伪类  
语言伪类`:lang`伪类，用来设置使用特殊语言的内容样式,如`:lang(en)`的内部应该为英语。  
**注意：lang和一般的伪类选择器不同，这个有继承性** 例如： 
```html  
<body lang="en">
    <p>SIPC15</p>
</body>
```  
如果使用`[lang=en]`则只能选到body元素，因为p元素没有lang属性。但是使用`:lang(en)`则能同时选择到body和p元素。  
### 结构伪类  
结构伪类，在css3中增加了很多种类，对于复杂的html结构经常会用到结构伪类来选择。他分为三种：根伪类，子元素过滤伪类与空伪类。
**根伪类**由他在文档的位置判定，**子元素过滤伪类**是根据他在其父元素的所有孩子的位置或标签类型判定，**空伪类**是根据他孩子的个数判定。    
`:root`伪类用于选择根元素，在HTML中通常是html元素  
**:nth-child**是所有子元素过滤伪类的基础。它带有参数，可以是纯数字，代数式，或者单词。如果是纯数字，数字从1计数；如果是代数式，n则从零递增。用图来展示     
1.`nth-child(8)`选择第8个li元素：    
![](/image/cssnth1.png)  
2.`nth-child(n+6)`选择大于或等于6的元素  
![](/image/cssnth2.png)   
3.`:nth-child(-n+9)`选取小于或者等于9的元素     
![](/image/cssnth3.png)   
4.`nth-child(n+4):nth-child(-n+8)`选择大于等于4并且小于等于8的元素  
![](/image/cssnth4.png)  
5.`nth-child(2n)`为选择偶数位的元素，`nth-child(2n-1)`为选择奇数位上的元素，`nth-child(3n+1)`则是以3个为一组，取第一个元素。  
6.`nth-of-type`和`nth-child`类似,规则是将当前元素的父节点的所有元素按照其tagName分组，只要其参数符合它在哪一组的位置就被匹配到。如下规则：  
`span:nth-of-type(n+3) div:nth-of-type(2n+2)`   
```css  
/* 这部分是蓝色圆*/
span:nth-of-type(n+3) {
    background-color: #298EB2;
    box-shadow: inset -3px -3px 10px rgba(0, 0, 0, 0.4), 0 0 10px black;
}
/* 这部分是黄色的方块*/
div:nth-of-type(2n+2) {
    background-color: #E17149:
    box-shadow: inset -3px -3px 10px rgba(0, 0, 0, 0.4), 0 0 10px black; 
} 
```   
![](/image/cssnth5.png)   
**其他的例子请参见[nthmaster.com](http://nthmaster.com/)**    
7.`first-child`用于选择第一个子元素，效果等同于`nth-child(1)`。对应有`first-of-type`  
8.`last-child`用于选择最后一个子元素，效果等同与`nth-last-child(1)`。对应有`last-of-type`    
9.`only-child`用于选择唯一的子元素，当子元素个数超过1个时，无效。对应有`only-of-type`  
10.`empty`用于选择那些不包含任何元素节点、文本节点、CDATA节点的元素，但是里面可以有注释节点.     

### 取反伪类  
取反伪类`:not`伪类，其参数为一个或多个简单选择器，里面用逗号隔开。  

## 选择器的效率  
### 解析顺序  
样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。
从右向左匹配这一点很关键，Sizzle引擎也是这样设计的。之后会细说。  
### css执行效率  
如果你非常在意页面的性能，那千万别使用CSS3选择器。实际上，在所有浏览器中，用 class 和 id 来渲染，比起那些使用同胞选择器、后代选择器、子选择器（sibling, descendant and child selectors）对页面性能的改善更值得关注。  
Google 资深web开发工程师Steve Souders对CSS选择器的效率从高到低做了一个排序：   

1. id选择器（#myid）  
2. 类选择器（.myclassname） 
3. 标签选择器（div,h1,p）  
4. 相邻选择器（h1+p）  
5. 子选择器（ul < li）  
6. 后代选择器（li a）  
7. 通配符选择器（*）  
8. 属性选择器（a[rel="external"]）  
9. 伪类选择器（a:hover,li:nth-child）  
在性能优化中，我们会对css的优化进行更深入的解释。    


# 结构与层叠   
## 选择器的特异度    
在上面我们说了，选择器用来选择元素。那么当多个选择器同时指向了一个元素，那么对于有冲突的元素样式该如何选择，就要看
选择器本身的权重(特异度)了。高权重的选择器会覆盖掉低权重的选择器中的相同值。  
选择器的权重(特异度)由`0，0，0，0`四部分来描述，规则如下：  

* 通配符选择器权重为: 0, 0, 0, 0
* 对于选择器中给定的各个ID属性值，加：0, 1, 0, 0  
* 对于选择器中给定的各个类属性值，属性选择或伪类，加: 0, 0, 1, 0
* 对于选择器中给定的各个元素和伪元素，加：0, 0, 0, 1  
* 结合符和通配选择器对特殊性没有任何贡献    

|选择器|内联|ID个数|（伪）类个数|标签个数|特异度|
|:----------:|--------------|--------------|--------------|--------------|--------------|   
|#nav .list li a:hover|	0|1|2|2|0122|
|.hd ul.links a|0|0|2|2|0022|   

但有时为了某个声明特别重要，超过了其它声明。CSS2.1称之为重要声明，并允许在这些声明的结束分好之前插入`!important`来标志。这个规则永远排在最前边。   

## 继承  
上面说的特异度对于理解文档如何应用css声明很重要，同样还有一个概念很重要，继承。基于继承机制，样式不仅会用用到指定的元素上，
还会应用到它的后代元素。但是并不是所有的属性都可以继承，这个要格外注意。继承的属性是没有特异度的，甚至低于0, 0, 0, 0。这也说明了继承来的
属性，会轻易的被css覆盖掉。  

## 层叠  
层叠就是为了解释，如果两个特异度相同的css规则，同时应用到了一个元素上，会怎么处理呢？处理规则如下：   

1. 找出所有相关规则，这些规则都包含与一个给定元素匹配的选择器。
2. 按显示权重(特异度)对应用钙元素的所有声明排序，`!important`的规则高于没有`!important`的规则。按`来源`对应用到给应元素的所有声明排序。 
3. 按特异度对应用到给定元素的所有声明排序，较高特异度的大于低的。
4. 按出现顺序对应用到给定元素的所有声明排序，一个声明在样式表或文档中越后出现，他的权重越大。  

**其中来源指 用户代理样式(浏览器默认样式) < 声明**  

# 附录  
参考资料如下：  

* [CSS权威指南](https://item.jd.com/10100250.html)  
* [图解CSS3](https://item.jd.com/11494721.html)    
* [CSS参考手册](http://www.css88.com/book/css/)  
* [W3C组织](https://www.w3.org/)
* [jQuery框架设计](https://item.jd.com/11436424.html)





 


