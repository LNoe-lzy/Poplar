CSS动画指南 - 动画使用技巧
===  
这里介绍一下，在制作css动画中遇到的问题，和一些css动画的使用技巧。

# 动画使用技巧  
## 规划关键帧(动画过程)  
我们在制作补间动画的时候，关键帧是我们要书写的内容，这部分决定了动画的效果。为此有必要根据沟通和分析合理的规划出
动画的属性分解表和时间轴，例如下面这个属性分解的例子：  
![](/image/css8-3.png)  　　

## transform 动画不同步问题  
在制作一个复杂的动画的时候，你有可能对元素有多个transform的同时变化，然而transform 并不像你想的那样同步发生，
而是按照一定顺序。最右边的操作最先执行，然后往左依次执行。例如下面的代码中scale首先执行，然后是translate，最后是rotate：    

```css  
@keyframes foo {
 to {/*         3rd           2nd              1st      */
   transform: rotate(90deg) translateX(30px) scale(1.5);}}
```    

大多数情况下这不是我们想要的，通常我们希望这些操作同时发生。
此外，如果你把 transform 分割成多个 keyframe，事情会变得更加复杂，有些操作同步，
有些操作不同步。比如下面这个例子：  

```css  
@keyframes foo {
    30%{
        transform: rotateY(360deg);
    }
    65%{
        transform: translateY(-30px) rotateY(-360deg) scale(1.5);
    }
    90%{
        transform: translateY(10px) scale(0.75);
    }
}  
```  
这段代码的动画效果顺序，我们无法预测。为了解决这一问题，我们只能采取一个暴力的手段，即给要执行过个变换的动画
套上多个`<div>`标签，每个标签应用一种需要的变化，这样就不会发生干扰。查看下面的例子，就是通过加`<div>`手段解决的：  
[transform动画不同步研究](http://59.67.152.41:10080/codepencil/index.php/Code/index/cid/143)  
如果希望有一种优雅的方式解决的话，我们会采用 transform的Matrix(矩阵)做变换，这个之后讨论。  

[W3C css transform module level 2](https://drafts.csswg.org/css-transforms-2/)上，已经对这一问题
进行了修正，我们可以不用再关心动画的执行顺序，他们可以同时执行了。然而目前这一提案依然在修订中，并没有正式的浏览器能够支持。
你可以下载 google Chrome Canary(金丝雀)版本的浏览器体验一下。 

## 使用负的延迟值  
如果你需要同时执行多个动画并错开它们的开始时间，可以使用`animation-delay`。
但是这会导致用户打开网页时有些元素需要静止一段时间才会开始移动。
此时可以给`animation-delay`设置一个负数，这样会将播放头向前移动，
因此用户打开网页的时候所有动画都会播放。使用这种方式可以通过共享一套 keyframes 来实现不同的动画。  

## animation-play-state 控制动画播放状态   
### 1. 动画触发  
在使用css制作的动画时，我们一般是定义一个类，比如`.active`来表示动画。当对应的div要产生动画的时候，我们就通过
js给这个div加上`.active`来实现。   

```js
element.classList.add("active");  
```  

当我们需要重新加载动画的时候，可以利用reflow重新出发animation:  

```js  
element.classList.remove("active");
element.offsetWidth = element.offsetWidth;
element.classList.add("active");  
```  
这里第二行代码，是为了强制element做layout，这样才能有动画效果(具体原因，在渲染性能优化部分说明)   
### 2. 动画播放控制  
如何具体控制动画的播放呢，一般我们都是加入动画类来完成的，例如：  

```css   
.element1 { /* 尺寸与定位 */ }
.element2 { /* 尺寸与定位 */ }
.element3 { /* 尺寸与定位 */ }  

.active .element1 { animate: name1 1s; }
.active .element2 { animate: name2 1s; }
.active .element3 { animate: name2 1s; } 
```   
这里提供一种用`animation-play-state`的方法：  

1.动画相关CSS代码直接写在元素上：  

```css   
.element1 { /* 尺寸与定位 */ animate: name1 1s; }
.element2 { /* 尺寸与定位 */ animate: name2 1s; }
.element3 { /* 尺寸与定位 */ animate: name3 1s; }
```  

2.创建一个类名，如`.animate`，凡是使用到了animation动画的元素都添加这个类名； 
3.如下CSS代码：  

```css  
.animate {
    animation-play-state: paused;
}
.active .animate {
    animation-play-state: running;
}
```  

这种写法相对而言代码层次清晰，控制关系明确。有利于后期的维护与扩展。  

### 不同状态下的连续动画  
例如给一个动画显示淡出，然后无限上下浮动。这里一个keyframes肯定不行，我们要对动画`分解`和`延时`。  
首先声明两个动画效果：  

```css   
@keyframes fadeIn { /* ... */ }
@keyframes float { /* ... */ } 
```  

```html  
<div class="element">动画</div>  
``` 
之后应用这两个关键帧：  
#### 1. animation 多动画    
```css    
.element { animation: fadeIn 1s, float .5s 1s infinite; }  /* 我淡出, 需要1秒；我1秒后开始无限漂浮 */
```  
其中float .5s 1s infinite这里的1s就是无限漂浮动画执行延迟的时间，于是，两个动画完美配合，感觉就像是一个动画。实际上，就是一个动画，所有CSS3 animation动画走同一个UI线程，这也是为何推荐使用CSS实现动画效果的原因。  

#### 2. 标签嵌套
我们还可以通过嵌套标签的形式实现连续动画，例如：    

```html    
<div class="element-wrap"><div class="element">小火箭</div></div>
```  

```css  
.element-wrap { animation: fadeIn 1s; }          /* 我淡出, 需要1秒 */
.element { animation: float .5s 1s infinite; }   /* 我1秒后开始无限漂浮 */  
```  

这个例子类似之前解决并行时候的方案，当我们需要有多组动画并行，并且有各部分动画重叠的效果的时候采用标签嵌套就十分方便了。  
即我们可以吧公共的动画提取出来，放入一个父级div来执行就好了。   

### 无侵入定位和居中定位准则  
> 这里的“无侵入定位”指不受animation影响的元素定位，
包含两部分：一是不使用keyframes关键帧决定初始位置；二是不要使用keyframes中出现的属性定位。  

1.不使用keyframes决定初始位置    
应该都知道，CSS3 animation的fill-mode可以决定元素动画结束前后的位置，也就是也具有定位的作用。此时，可能就会有小伙伴，故作聪明，利用animation keyframes 0% {}或form {}去做定位，貌似，还省了写代码。看上去很赞，实际上狭隘了，这对于对animation支持不佳或不支持的浏览器实际上是不友好的，例如Android2.3不支持animation-fill-mode, IE6-IE9不支持CSS3 animation，于是乎，当遭遇这些浏览器的时候，页面动画元素的布局实际上是毁掉的。所以，这些动画元素定位的时候，需要使用“无侵入定位”  

2.不使用keyframes中出现的属性定位  
举个例子，有个球，正好定位在模块的中心，同时有个无限旋转效果。使用`transform: translate(-50%,-50%)`居中定位再合适不过了，于是，使用了transform定位。此时，冲突发生，旋转动画也是需要transform变换的。  

```css  
@keyframes spin {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
}  
```  
因此，建议使用传统left/top/margin进行定位，与transform变换动画“无侵入”。    

> 这里的“居中定位准则”包含两部分：一是元素定位在容器中间位置；二是元素的定位方式为居中定位。  

1.元素定位在容器中间  
容器以及容器内的动画元素可以看成是一个动画模块，为了这个模块可以轻松驾驭水平布局和垂直局部，里面的动画元素形成的整体一定要在容器的中间，不要被设计稿或周围环境影响。  

2.定位方式为居中定位  
所谓“居中定位”是相对“传统定位”而言的。Web页面中的模块、文字什么的默认都是相对于左上角堆砌的，所以，很自然地，我们在重构页面，做布局，写交互效果的时候，也都是相对左上角定位。活用元素本身的定位特性，这是很赞的也推荐这么做！但是，如果你和多元素CSS动画打交道，可能就需要改变下惯性思维了，很重要的一点就是“从以左上角为参考点变成以中心点为参考点”。    
我们在实现多元素动画效果时候，会出现两类角色：一是容器；二是容器里面诸多动画元素。  
其中，对于容器元素，尤其在做移动端产品时候，我们很自然会让其居中定位：  

```css    
.container {
    position: absolute; left: 50%; top: 50%;
    transform: translate3d(-50%, -50%, 0);
}
```
这样，各种尺寸的手机，我们都能让其居中显示（大尺寸可能需要一定的缩放）。  

这里我们也让容器里面的元素居中定位，例如原始的div是这样的，是从左上角定位（或右上角定位）：  

```css
.example {
    position: absolute; left: 100px; top: 100px;
}  
```  
现在变成中心点定位`+ margin`偏移：  

```css 
.example {
    position: absolute; left: 50%; top: 50%; 
    margin-left: -100px; margin-top: -100px;
}  
```  

这么做的好处主要是为了移动端的适配。因为当我们以左上角做动画的时候，如果屏幕尺寸发生了改变，很容易导致div发生偏移。  
比如原本是聚在一起的div，由于屏幕变大，会分散开来，这样我们的动画GG了。  
所以如果我们是按照居中定位的话，就不会产生这种问题，总结起来就是：  

* 动画元素之间的位置关系不受容器尺寸影响；
* 居中特性遭遇多场景时适应性更强；  

# 流畅自然的动画  
这里呢主要是是交互设计的内容，不涉及代码，如果有问题希望指出，因为我也不懂设计O(∩_∩)O哈哈~。但觉得还是有必要说一下：  
## 运动动画  
我们先从最简单的运动动画说起。我们客观物理规律还是得从牛顿第二定律说起：`F＝ma`  
通俗点来说，就是运动动画响应变化情况与执行动画的物体本身有关。如果你想表现的物体是一个沉甸甸的，那么他们的起始动画响应/参数的变化会比较慢。反之，物体是轻巧的，那么其起始动画响应/参数的变化会比较快。  
![](/image/css8-5.png)  
从图上可以看到如果是相同的操作且移动相同的距离，轻巧的所花的时间越短。  

## 阻尼动画   
提到阻尼，需要介绍三个概念：临界阻尼、过阻尼、欠阻尼。
### 临界阻尼  
生活中一些高档的门或橱柜。他们在开合的过程中为了不造成太大的声响，他们的机械结构阻尼会尽量设计接近临界阻尼。这个过程最容易让人接受，不会感觉有外界干扰。过阻尼和欠阻尼，通常能让你感觉到有一只隐形的手，阻碍或促进运动。  
### 过阻尼  
就是阻尼很大，阻碍运动的发展。有些自动门或电梯门在闭合的过程中，在最后段里往往需要更长的时间。另外，记忆枕的恢复的过程也是过阻尼。  
### 欠阻尼  
阻尼不够，继而形成了振荡的特征。生活中的一些弹簧门，在关闭的过程中，会多次摆动，最终趋于闭合。  
![](/image/css8-6.png)  
做一个比较细腻的界面动画时候，如果追求理性一些，可以把动画的成果拆解成三个阶段。启动、运行、收尾。设计师需要花更多的时间去考虑启动与收尾过程。  
![](/image/css8-7.png)  
* 启动阶段：体现力、质量、环境，可以表现材质的轻盈与厚重。
* 收尾阶段：体现质量、速度、环境。阻尼通常在这个阶段体现。  

## 呼吸动画  
呼吸动画，常用于界面元素的提醒。  
对于这个动画，设计师最直观的印象就是闪烁。在实施的过程中，对于闪烁一词会被赋予不同的理解。  
* 设计师眼中的闪烁：“渐显 -> 渐隐 -> 渐显 -> 渐隐”；
* 工程师眼中的闪烁：“显示 -> 隐藏 -> 显示 -> 隐藏”；  

如何把动画做得更细腻，就在于如何将渐显与渐隐的过程如何描述得更加仔细。对于最早的渐显、渐隐动画，应用到的三角函数。  
![](/image/css8-8.png)  
这个三角函数能满足大部分的呼吸动画要求，但是真正的呼吸并不是这样的，我们可以尝试呼吸一下会发现在我们的在吸气的阶段，很快会就达到肺撑满的状态，然后吐气的阶段可以持续很久。
因此需要修正这个三角函数如下：  
![](/image/css8-9.png)  
k=1/3，t=6, n={1,2,3,...}  

## 动画设计  
关于动画设计的，这个我觉得这不是我这种小小的码农能做到的，看来还是得找个`设计师`当女朋友啊，(* ￣3)(ε￣ *)。 这里推荐一些设计的文章吧：  
* [以电影之眼看CSS3动画（一）](https://aotu.io/notes/2015/11/23/css3-animation-to-movie-part_1/)  
* [以电影之眼看CSS3动画（二）](https://aotu.io/notes/2015/11/23/css3-animation-to-movie-part_2/)  
* [动效设计原理](https://isux.tencent.com/20122.html)  
* [聊聊那些愉悦的动画效果](https://isux.tencent.com/about-design-animation.html)    

# 动画性能  
这部分先留着，性能优化再讲。  

# 附录  
参考资料如下：  
* [腾讯ISUX博客](https://isux.tencent.com/)  
* [京东凹凸实验室](https://aotu.io/)  




